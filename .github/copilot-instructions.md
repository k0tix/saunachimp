# SaunaChimp Event System

## Event Queue Architecture

Events are generated by `backend/src/services/housekeeping.ts` and stored in memory:

```typescript
interface GameEvent {
  event_type: string;  // e.g., "LOYLY_THROW", "SCENE_WIN"
  run_at: number;      // Unix timestamp
}

// Events are stored in:
housekeepingState.game.event_queue: GameEvent[]

// Consumed via:
GET /api/control/scene/events
// Returns events where run_at <= Date.now(), then removes them
```

## Scene Handlers Pattern

Each scene must export a handler function:

```typescript
// backend/src/services/scenes/scene1.ts
export const handleScene1 = async (
  status: HousekeepingStatus
): Promise<GameEvent[]> => {
  // Initialize on first run
  if (getHousekeepingSceneStatus() === 0) {
    setHousekeepingSceneStatus(1);
    setHousekeepingSceneStartAt(Date.now());
    return [
      { event_type: 'START_SCENE', run_at: Date.now() },
      { event_type: 'SCENE_WIN', run_at: Date.now() + 60000 }
    ];
  }

  // Generate events based on sensor data
  if (status.info.loyly) {
    return [{ event_type: 'LOYLY_THROW', run_at: Date.now() }];
  }

  return [];
};
```

## Frontend Event Handling Pattern

All frontend scenes should listen for events via postMessage:

```javascript
// Frontend scene event handler
window.addEventListener('message', (event) => {
  if (event.data.type === 'SCENE_API_EVENT') {
    switch(event.data.event) {
      case 'THROW_LOYLY':
        game.throwLoyly();
        break;
      case 'SCENE_WIN':
        game.gameWon();
        break;
    }
  }
});
```

## Key Conventions

- Event types: `SCREAMING_SNAKE_CASE`
- Events are one-time actions (consumed when fetched)
- Housekeeping runs every 10 seconds
- Scene ID 0 = no active scene
- Always return `GameEvent[]` from scene handlers, even if empty

