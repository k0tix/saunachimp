<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sauna Collection</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            color: #fff;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        #gameCanvas {
            flex: 1;
            background: #1a1410;
        }
        .sidebar {
            width: 300px;
            background: #1a1a2e;
            padding: 15px;
            overflow-y: auto;
            border-left: 3px solid #e94560;
        }
        .title {
            font-size: 14px;
            color: #e94560;
            margin-bottom: 15px;
            text-align: center;
            padding: 10px;
            background: rgba(233, 69, 96, 0.1);
            border: 2px solid #e94560;
        }
        .stats {
            background: #16213e;
            padding: 10px;
            margin-bottom: 15px;
            border: 2px solid #0f3460;
            font-size: 9px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        .inventory {
            background: #16213e;
            padding: 10px;
            margin-bottom: 15px;
            border: 2px solid #0f3460;
        }
        .section-title {
            font-size: 11px;
            color: #e94560;
            margin-bottom: 10px;
        }
        .item-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .item-card {
            background: #0f3460;
            border: 2px solid #000;
            padding: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .item-card:hover {
            border-color: #e94560;
            transform: scale(1.05);
        }
        .item-card.locked {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .item-card.selected {
            border-color: #0f0;
            background: #1a4d2e;
        }
        .item-icon {
            width: 50px;
            height: 50px;
            margin: 0 auto 5px;
        }
        .item-name {
            font-size: 8px;
            color: #ccc;
        }
        .rarity {
            font-size: 7px;
            padding: 2px 4px;
            margin-top: 3px;
            border-radius: 2px;
            display: inline-block;
        }
        .common { background: #95a5a6; color: #000; }
        .rare { background: #3498db; }
        .epic { background: #9b59b6; }
        .legendary { background: #f39c12; }
        .btn {
            width: 100%;
            padding: 10px;
            background: #e94560;
            border: 2px solid #000;
            color: white;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            margin-bottom: 8px;
        }
        .btn:hover {
            background: #ff6b81;
        }
        .console {
            background: #000;
            padding: 8px;
            font-size: 8px;
            color: #0f0;
            height: 100px;
            overflow-y: auto;
            border: 2px solid #0f3460;
        }
        .coord-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: #0f0;
            padding: 10px 20px;
            font-size: 16px;
            border: 2px solid #0f0;
            z-index: 2000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="gameCanvas"></div>
        <div id="coordDisplay" class="coord-display" style="display:none;">X: 0, Y: 0</div>
        <div class="sidebar">
            <div class="title">FINNISH SAUNA</div>
            
            <div class="stats">
                <div class="stat-row">
                    <span>TEMP:</span>
                    <span id="temp">0C</span>
                </div>
                <div class="stat-row">
                    <span>HUM:</span>
                    <span id="hum">0%</span>
                </div>
                <div class="stat-row">
                    <span>MONEY:</span>
                    <span id="money">10000</span>
                </div>
                <div class="stat-row">
                    <span>ITEMS:</span>
                    <span id="count">0/12</span>
                </div>
            </div>

            <button class="btn" id="clearBtn">CLEAR</button>
            
            <div class="inventory">
                <div class="section-title">COLLECTION</div>
                <div class="item-grid" id="itemGrid"></div>
            </div>
            
            <div class="console" id="console">
                <div>&gt; READY</div>
            </div>
        </div>
    </div>

    <script>
        const SERVER_URL = 'http://localhost:8080';
        const USER_ID = 'user_001';

        const app = new PIXI.Application({
            width: window.innerWidth - 300,
            height: window.innerHeight,
            backgroundColor: 0x000000,
            antialias: true
        });
        document.getElementById('gameCanvas').appendChild(app.view);

        const container = new PIXI.Container();
        app.stage.addChild(container);

        // Load background image (Habbo sauna room)
        const bgImagePath = 'habbo_sauna_room.avif';
        
        PIXI.Assets.load(bgImagePath).then((texture) => {
            const bg = new PIXI.Sprite(texture);
            bg.width = app.screen.width;
            bg.height = app.screen.height;
            container.addChildAt(bg, 0);
        }).catch(() => {
            // Fallback: Draw simple gradient background
            const gradient = new PIXI.Graphics();
            gradient.beginFill(0x2a1810);
            gradient.drawRect(0, 0, app.screen.width, app.screen.height);
            container.addChildAt(gradient, 0);
            log('ADD habbo_sauna_room.jpg TO FOLDER');
        });

        // Base coordinates at reference canvas width
        const BASE_WIDTH = window.innerWidth - 300;
        const BASE_HEIGHT = window.innerHeight;
        
        // Isometric spots for each product type
        const spotsBase = [
            {type: 'kiuas', x: 550, y: 610, label: 'KIUAS', slotId: 'kiuas_1'},
            {type: 'lauteet', x: 630, y: 420, label: 'LAUTEET', slotId: 'lauteet_1'},
            {type: 'generic', x: 700, y: 500, label: 'OLUT', slotId: 'generic_1'},
            {type: 'saunakauha', x: 420, y: 567, label: 'KAUHA', slotId: 'saunakauha_1'},
            {type: 'kiilu', x: 490, y: 567, label: 'KIULU', slotId: 'kiilu_1'}
        ];
        
        let spots = spotsBase.map(s => ({...s}));

        let items = [];

        let sensorData = [];
        let dataIndex = 0;
        let unlocked = new Set();
        let money = 0;
        let maxTemp = 0;
        let selected = null;
        let placed = {};

        const coordDisplay = document.getElementById('coordDisplay');

        // Mouse tracker for finding positions
        app.view.addEventListener('mousemove', (e) => {
            const rect = app.view.getBoundingClientRect();
            const x = Math.round(e.clientX - rect.left);
            const y = Math.round(e.clientY - rect.top);
            coordDisplay.textContent = `X: ${x}, Y: ${y}`;
            coordDisplay.style.display = 'block';
        });

        app.view.addEventListener('mouseleave', () => {
            coordDisplay.style.display = 'none';
        });

        app.view.addEventListener('click', (e) => {
            const rect = app.view.getBoundingClientRect();
            const x = Math.round(e.clientX - rect.left);
            const y = Math.round(e.clientY - rect.top);
            console.log(`Clicked at X: ${x}, Y: ${y}`);
        });

        function scaleSpots() {
            const scaleX = app.screen.width / BASE_WIDTH;
            const scaleY = app.screen.height / BASE_HEIGHT;
            
            spots.forEach((spot, idx) => {
                const base = spotsBase[idx];
                spot.x = base.x * scaleX;
                spot.y = base.y * scaleY;
                
                if (spot.graphics) {
                    spot.graphics.x = spot.x;
                    spot.graphics.y = spot.y;
                }
            });
        }

        // Draw spots with overlay indicators
        function drawSpots() {
            spots.forEach(spot => {
                const spotGfx = new PIXI.Graphics();
                
                // Draw isometric tile highlight
                spotGfx.lineStyle(2, 0xffff00, 0.4);
                spotGfx.beginFill(0xffffff, 0.1);
                const sw = 40, sh = 20;
                spotGfx.drawPolygon([
                    0, 0,
                    sw, sh/2,
                    0, sh,
                    -sw, sh/2
                ]);
                
                spotGfx.x = spot.x;
                spotGfx.y = spot.y;
                spotGfx.interactive = true;
                spotGfx.buttonMode = true;
                
                // Hover effect
                spotGfx.on('mouseover', () => {
                    spotGfx.clear();
                    spotGfx.lineStyle(3, 0x00ff00, 0.8);
                    spotGfx.beginFill(0x00ff00, 0.2);
                    spotGfx.drawPolygon([
                        0, 0,
                        sw, sh/2,
                        0, sh,
                        -sw, sh/2
                    ]);
                });
                
                spotGfx.on('mouseout', () => {
                    if (!placed[spot.type]) {
                        spotGfx.clear();
                        spotGfx.lineStyle(2, 0xffff00, 0.4);
                        spotGfx.beginFill(0xffffff, 0.1);
                        spotGfx.drawPolygon([
                            0, 0,
                            sw, sh/2,
                            0, sh,
                            -sw, sh/2
                        ]);
                    }
                });
                
                spotGfx.on('click', () => placeItem(spot));
                
                const label = new PIXI.Text(spot.label, {
                    fontSize: 9,
                    fill: 0xffffff,
                    alpha: 0.6,
                    fontWeight: 'bold'
                });
                label.anchor.set(0.5);
                label.y = sh + 10;
                spotGfx.addChild(label);
                
                container.addChild(spotGfx);
                spot.graphics = spotGfx;
            });
        }

        drawSpots();

        function drawIsometricItem(item) {
            const g = new PIXI.Graphics();
            
            const rarityColors = {
                common: [0x666666, 0x888888],
                rare: [0x3498db, 0x5dade2],
                epic: [0x9b59b6, 0xbb8fce],
                legendary: [0xf39c12, 0xf8c471]
            };
            
            const [dark, light] = rarityColors[item.rarity];
            
            switch(item.type) {
                case 'kiuas': // Stove - box with flames
                    // Front face
                    g.beginFill(dark);
                    g.drawPolygon([0,20, 40,0, 40,40, 0,60]);
                    // Top face
                    g.beginFill(light);
                    g.drawPolygon([0,20, 40,0, 80,20, 40,40]);
                    // Right face
                    g.beginFill(dark);
                    g.drawPolygon([40,40, 80,20, 80,60, 40,80]);
                    // Flames
                    g.beginFill(0xff6600);
                    g.drawPolygon([30,10, 40,0, 50,10, 45,20, 35,20]);
                    break;
                    
                case 'saunakauha': // Ladle - vertical with bowl
                    g.beginFill(dark);
                    g.drawRect(36, 0, 8, 60);
                    g.beginFill(light);
                    g.drawEllipse(40, 65, 20, 10);
                    g.beginFill(dark);
                    g.drawEllipse(40, 63, 18, 8);
                    break;
                    
                case 'kiilu': // Bucket
                    g.beginFill(dark);
                    g.drawPolygon([20,30, 30,25, 50,25, 60,30, 60,70, 20,70]);
                    g.beginFill(light);
                    g.drawPolygon([20,30, 60,30, 60,10, 50,5, 30,5, 20,10]);
                    // Handle
                    g.lineStyle(3, dark);
                    g.arc(40, 20, 15, Math.PI, 0);
                    break;
                    
                case 'lauteet': // Benches - stacked platforms
                    g.beginFill(dark);
                    g.drawPolygon([0,40, 80,20, 80,30, 0,50]);
                    g.beginFill(light);
                    g.drawPolygon([0,40, 80,20, 160,40, 80,60]);
                    break;
                    
                case 'generic': // Bottle (Olut)
                    g.beginFill(dark);
                    g.drawPolygon([20,30, 30,25, 50,25, 60,30, 60,70, 20,70]);
                    g.beginFill(light);
                    g.drawPolygon([20,30, 60,30, 60,10, 50,5, 30,5, 20,10]);
                    // Neck
                    g.beginFill(0x666666);
                    g.drawRect(35, 0, 10, 10);
                    // Label
                    g.beginFill(0xffaa00);
                    g.drawRect(25, 40, 30, 15);
                    break;
            }
            
            return g;
        }

        function placeItem(spot) {
            if (!selected) {
                log('NO ITEM SELECTED');
                return;
            }
            
            const item = items.find(i => i.id === selected);
            
            if (item.type !== spot.type) {
                log('WRONG SPOT FOR ' + item.name);
                return;
            }
            
            placeItemInScene(spot, item);
            log('PLACED: ' + item.name);
            selected = null;
            updateInventory();
        }

        const itemIcons = {
            kiuas: 'ðŸ”¥',
            lauteet: 'ðŸª‘',
            generic: 'ðŸº',
            saunakauha: 'ðŸ¥„',
            kiilu: 'ðŸª£'
        };

        function updateInventory() {
            const grid = document.getElementById('itemGrid');
            grid.innerHTML = '';
            
            items.forEach(item => {
                const isOwned = unlocked.has(item.id);
                const div = document.createElement('div');
                div.className = `item-card ${isOwned ? '' : 'locked'} ${selected === item.id ? 'selected' : ''}`;
                
                const icon = isOwned ? itemIcons[item.type] : 'ðŸ”’';
                
                div.innerHTML = `
                    <div class="item-icon" style="font-size: 30px; line-height: 50px;">${icon}</div>
                    <div class="item-name">${isOwned ? item.name : '???'}</div>
                    ${isOwned ? `<div class="rarity ${item.rarity}">${item.rarity.toUpperCase()}</div>` : 
                        `<div style="font-size: 10px; color: #f39c12; margin-top: 5px;">ðŸ’° ${item.price}</div>
                         <button class="btn" style="font-size: 8px; padding: 4px; margin: 5px 0 0 0;">BUY</button>`}
                `;
                
                if (isOwned) {
                    div.onclick = () => {
                        selected = item.id;
                        updateInventory();
                        log('SELECTED: ' + item.name);
                    };
                } else {
                    const buyBtn = div.querySelector('.btn');
                    if (buyBtn) {
                        buyBtn.onclick = async (e) => {
                            e.stopPropagation();
                            await buyItem(item);
                        };
                    }
                }
                
                grid.appendChild(div);
            });
        }

        function updateStats() {
            if (!sensorData.length) return;
            
            const data = sensorData[dataIndex];
            const temp = data.data.temp;
            const hum = data.data.hum;
            
            if (temp > maxTemp) maxTemp = temp;
            
            document.getElementById('temp').textContent = temp.toFixed(1) + 'C';
            document.getElementById('hum').textContent = hum.toFixed(1) + '%';
            document.getElementById('money').textContent = money;
            document.getElementById('count').textContent = unlocked.size + '/' + (items.length || 0);
            
            dataIndex = (dataIndex + 1) % sensorData.length;
        }

        function updateMoneyDisplay() {
            document.getElementById('money').textContent = money;
            document.getElementById('count').textContent = unlocked.size + '/' + (items.length || 0);
        }

        async function buyItem(item) {
            log('BUY ATTEMPT: ' + item.name + ' | Price: ' + item.price + ' | Your money: ' + money);
            
            if (money < item.price) {
                log('INSUFFICIENT FUNDS: Need ' + item.price + ', Have ' + money);
                return;
            }

            if (!item.productId) {
                log('PRODUCT NOT LINKED');
                return;
            }

            try {
                const response = await fetch(`${SERVER_URL}/api/owned-products/purchase/${USER_ID}/${item.productId}`, {
                    method: 'POST'
                });

                const result = await response.json();

                if (result.success) {
                    money = result.data.transaction.new_balance;
                    unlocked.add(item.id);
                    updateInventory();
                    updateMoneyDisplay();
                    log('PURCHASED: ' + item.name + ' (-' + item.price + ')');
                } else {
                    log('PURCHASE FAILED: ' + result.message);
                }
            } catch (error) {
                log('ERROR: ' + error.message);
            }
        }

        async function loadOwnedProducts() {
            try {
                const response = await fetch(`${SERVER_URL}/api/owned-products/user/${USER_ID}`);
                const result = await response.json();

                if (result.success) {
                    result.data.forEach(owned => {
                        const item = items.find(i => i.productId === owned.product_id);
                        if (item) {
                            unlocked.add(item.id);
                            
                            // If item is in use, place it in the scene
                            if (owned.in_use === 1) {
                                const spot = spots.find(s => s.type === item.type);
                                if (spot) {
                                    placeItemInScene(spot, item);
                                }
                            }
                        }
                    });
                    updateInventory();
                    log('LOADED: ' + unlocked.size + ' OWNED ITEMS');
                }
            } catch (error) {
                log('LOAD ERROR: ' + error.message);
            }
        }

        function placeItemInScene(spot, item) {
            // Remove old item from this spot
            if (placed[spot.slotId]) {
                spot.graphics.children.forEach(c => {
                    if (c instanceof PIXI.Graphics && c !== spot.graphics.children[0]) {
                        spot.graphics.removeChild(c);
                    }
                });
            }
            
            const sprite = drawIsometricItem(item);
            sprite.x = -40;
            sprite.y = -60;
            sprite.scale.set(0.6);
            spot.graphics.addChild(sprite);
            
            placed[spot.slotId] = item.id;
        }

        async function loadProducts() {
            try {
                const response = await fetch(`${SERVER_URL}/api/products`);
                const result = await response.json();

                if (result.success) {
                    log('=== DATABASE PRODUCTS ===');

                    // Build items array from backend products
                    items = result.data.map(product => {
                        log(`ID: ${product.id} | ${product.name} | ${product.price}ðŸ’° | ${product.item_type}`);
                        
                        return {
                            id: product.id,
                            type: product.item_type,
                            name: product.name,
                            rarity: 'common',
                            price: product.price,
                            productId: product.id
                        };
                    });
                    
                    log('========================');
                    log('LOADED: ' + items.length + ' PRODUCTS');
                    
                    // Update inventory after items are loaded
                    updateInventory();
                }
            } catch (error) {
                log('PRODUCT LOAD ERROR: ' + error.message);
            }
        }

        document.getElementById('clearBtn').onclick = () => {
            placed = {};
            spots.forEach(spot => {
                spot.graphics.children.forEach(c => {
                    if (c instanceof PIXI.Graphics && c !== spot.graphics.children[0]) {
                        spot.graphics.removeChild(c);
                    }
                });
            });
            log('CLEARED');
        };

        function log(msg) {
            const console = document.getElementById('console');
            const line = document.createElement('div');
            line.textContent = '> ' + msg;
            console.appendChild(line);
            console.scrollTop = console.scrollHeight;
        }

        // Initialize
        async function init() {
            log('INITIALIZING...');
            
            // Load user data first
            await loadUser();
            
            await loadProducts();
            await loadOwnedProducts();
            
            // Load sensor data
            fetch('../mock_sauna_data.json')
                .then(r => r.json())
                .then(data => {
                    sensorData = data;
                    log('LOADED: ' + data.length + ' SENSOR RECORDS');
                    updateStats();
                })
                .catch(() => log('SENSOR DATA ERROR'));

            setInterval(() => {
                if (sensorData.length) updateStats();
            }, 3000);

            updateInventory();
        }

        async function loadUser() {
            try {
                log('FETCHING USER: ' + USER_ID);
                const response = await fetch(`${SERVER_URL}/api/users/${USER_ID}`);
                const result = await response.json();
                
                log('USER RESPONSE: ' + JSON.stringify(result));

                if (result.success) {
                    money = result.data.money;
                    updateMoneyDisplay();
                    log('USER: ' + result.data.username + ' | ðŸ’° ' + money);
                } else {
                    log('USER LOAD FAILED: ' + result.message);
                    money = 10000;
                    updateMoneyDisplay();
                }
            } catch (error) {
                log('USER LOAD ERROR: ' + error.message);
                money = 10000; // Fallback
                updateMoneyDisplay();
            }
        }

        init();
    </script>
</body>
</html>
